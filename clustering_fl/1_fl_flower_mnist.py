# -*- coding: utf-8 -*-
"""FL_Flower_MNIST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qGVz46QgkgXsp7n-AVxQw5DYx0VClC_4

criar um arquivo diferente para o cliente, servidor e simulação

na simulação, usaremos o cliente e servidor

executar esse codigo dessa maneira localmente

salvar as ativações e pesos no pickle

analisar separamente (calculo dos clusters)
"""

from google.colab import drive
drive.mount('/content/drive')

"""# Simulação Aprendizado Federado"""

!pip install flwr==1.0.0 flwr["simulation"]

from google.colab import drive
drive.mount('/content/drive')

data_path = '/content/drive/MyDrive/nonIID_MINIST/'

n_clients = 7

import flwr as fl
import pickle
import tensorflow as tf
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

from scipy.special import rel_entr
from scipy.stats import wasserstein_distance

import tensorflow as tf
import numpy as np
import random

"""## Criando um conjunto para o servidor."""

data_perc = 0.01 #percentual de dados que serão compartilhados de cada cliente
x_servidor = pd.DataFrame()

for i in range(n_clients):
  with open(f'{data_path}/client{i+1}.csv', 'rb') as train_file:
    data_client_i = pd.read_csv(train_file).drop('Unnamed: 0', axis = 1) 
    
    x_servidor = x_servidor.append(data_client_i.sample(int(len(data_client_i)*data_perc)))

x_servidor

#transformações necessárias

y_servidor =  x_servidor['label'].values
x_servidor.drop('label', axis=1, inplace=True)
# train.drop('subject', axis=1, inplace=True)
# train.drop('trial', axis=1, inplace=True)
x_servidor =  x_servidor.values

x_servidor

print(x_servidor.shape, y_servidor.shape)

def cka(X, Y):
    # Implements linear CKA as in Kornblith et al. (2019)
    X = X.copy()
    Y = Y.copy()

    # Center X and Y
    X -= X.mean(axis=0)
    Y -= Y.mean(axis=0)

    # Calculate CKA
    XTX = X.T.dot(X)
    YTY = Y.T.dot(Y)
    YTX = Y.T.dot(X)

    return (YTX ** 2).sum() / np.sqrt((XTX ** 2).sum() * (YTY ** 2).sum())

XTX = X.T.dot(X)
YTY = Y.T.dot(Y)
YTX = Y.T.dot(X)

X

X.T

sum(X.T[1] * X.T[1])

X.T @ X

XTX

X = np.random.random((3, 3))
Y = np.random.random((3, 3))

np.linalg.norm(np.cov(Y.T, X.T), 'fro' ) / ( np.sqrt( (np.linalg.norm(np.cov(X.T, X.T), 'fro')) * (np.linalg.norm(np.cov(Y.T, Y.T), 'fro'))) )

cka(X, Y)

"""## 1. Desenvolvendo Classe Cliente"""

class ClienteGabriel(fl.client.NumPyClient):

	def __init__(self, cid):

		self.cid = cid
		self.x_train, self.y_train, self.x_test, self.y_test = self.load_data()
		self.model     = self.create_model()
		self.round = 0
		print('++++++++++++++++++++++++++')

	def load_data(self):
		with open(f'{data_path}/client{self.cid+1}.csv', 'rb') as train_file:
			train = pd.read_csv(train_file).drop('Unnamed: 0', axis = 1) 
	    
		with open(f'/content/sample_data/mnist_test.csv', 'rb') as test_file: 	 
			test = pd.read_csv(test_file, dtype = np.float32)
			test = test.rename({'7': 'label'}, axis = 1)
	        
		y_train = train['label'].values
		train.drop('label', axis=1, inplace=True)
		# train.drop('subject', axis=1, inplace=True)
		# train.drop('trial', axis=1, inplace=True)
		x_train = train.values

		y_test = test['label'].values
		test.drop('label', axis=1, inplace=True)
		# test.drop('subject', axis=1, inplace=True)
		# test.drop('trial', axis=1, inplace=True)
		x_test = test.values
	    
		return x_train, y_train, x_test, y_test

	def create_model(self):
		model = tf.keras.models.Sequential()
		model.add(tf.keras.layers.InputLayer(input_shape=(x_servidor.shape[1],)))

		model.add(tf.keras.layers.Dense(128, activation='relu'))
	
		model.add(tf.keras.layers.Dense(128, activation='tanh'))
	
		model.add(tf.keras.layers.Dense(128, activation='elu'))
	
		model.add(tf.keras.layers.Dense(128, activation='relu',))
	
		model.add(tf.keras.layers.Dense(10, activation='softmax'))

		model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
		return model

	def get_parameters(self, config):
		return self.model.get_weights()

	def fit(self, parameters, config):
		
		print(config)

		#config recebe parametros do servidor
		self.model.set_weights(parameters)
		h = self.model.fit(self.x_train, self.y_train, 
		                                validation_data = (self.x_test, self.y_test),
																		verbose=1, epochs=10)

	
		# '''
		# adicionar metodos
		# metricas
		# ativações
		# modelos
		# '''

		msg2server = {
				"cliente_id": self.cid,
				# "ativacoes" : var_ativacoes
		}
		self.round += 1
		with open('acc.csv', 'a') as arquivo:

			arquivo.write(f"{self.round}, {self.cid}, {np.mean(h.history['accuracy'])}, {np.mean(h.history['loss'])}\n")
	 


		#acc = pd.read_csv('/content/acc.csv')		
		#acc = acc.append({'cid':self.cid, 
		#            'acc':accuracy}, ignore_index = True)
		#acc[['cid', 'acc']].to_csv('acc.csv')

		#config usado para passarar parametros para o servidor
		return self.model.get_weights(), len(self.x_train), msg2server


	def evaluate(self, parameters, config):
		self.model.set_weights(parameters)

		loss, accuracy = self.model.evaluate(self.x_test, self.y_test)
	
	
		return loss, len(self.x_test), {"accuracy" : accuracy}

"""## 2. Desenvolvendo Classe Servidor"""

from logging import WARNING
from flwr.server.strategy.aggregate import aggregate, weighted_loss_avg
from flwr.server.strategy.strategy import Strategy

from flwr.common import (
    EvaluateIns,
    EvaluateRes,
    FitIns,
    FitRes,
    MetricsAggregationFn,
    NDArrays,
    Parameters,
    Scalar,
    ndarrays_to_parameters,
    parameters_to_ndarrays,
)

from flwr.common.logger import log
from flwr.server.client_manager import ClientManager
from flwr.server.client_proxy import ClientProxy

actv = []

class AgregacaoCustomizada(fl.server.strategy.FedAvg):

  global x_servidor
  global y_servidor

  global actv

  def aggregate_fit(self, server_round, results, failures):
    
    def create_model():
      model = tf.keras.models.Sequential()
      model.add(tf.keras.layers.InputLayer(input_shape=(x_servidor.shape[1],)))
  
      model.add(tf.keras.layers.Dense(128, activation='relu'))
  
      model.add(tf.keras.layers.Dense(128, activation='tanh'))
  
      model.add(tf.keras.layers.Dense(128, activation='elu'))

      model.add(tf.keras.layers.Dense(128, activation='relu',))
  
      model.add(tf.keras.layers.Dense(10, activation='softmax'))

      return model

    modelo = create_model()

    """Aggregate fit results using weighted average."""
    lista_modelos = {'cids': [], 'models' : []}


    # Convert results
    weights_results = []
    for _, fit_res in results:
      client_id = str(fit_res.metrics['cliente_id'])
      parametros_client = fit_res.parameters

      #salvando os modelos (pesos)
      lista_modelos['cids'].append(client_id)
      lista_modelos['models'].append(parameters_to_ndarrays(parametros_client))

      weights_results.append((parameters_to_ndarrays(fit_res.parameters), fit_res.num_examples))

    lista_last = []
    lista_onetolast = []
    lista_first = []
    lista_second = []

    for w in lista_modelos['models']:

      modelo.set_weights(w)
      modelo.predict(x_servidor) 

      activation_last = get_layer_outputs(modelo, modelo.layers[-1], x_servidor, 0)
      activation_onetolast = get_layer_outputs(modelo, modelo.layers[-2], x_servidor, 0)

      activation_first = get_layer_outputs(modelo, modelo.layers[0], x_servidor, 0) 
      activation_second = get_layer_outputs(modelo, modelo.layers[1], x_servidor, 0)

      lista_last.append(activation_last)
      lista_onetolast.append(activation_onetolast)
      lista_first.append(activation_first)
      lista_second.append(activation_second)

    lista_modelos['actv_last'] = lista_last
    lista_modelos['actv_onetolast'] = lista_onetolast
    lista_modelos['actv_first'] = lista_first
    lista_modelos['actv_second'] = lista_second

    parameters_aggregated = ndarrays_to_parameters(aggregate(weights_results))

    actv.append(lista_modelos)

    metrics_aggregated = {}

    return parameters_aggregated, metrics_aggregated

  def aggregate_evaluate(
        self,
        server_round,
        results,
        failures,
    ):
        """Aggregate evaluation losses using weighted average."""
        if not results:
            return None, {}
        # Do not aggregate if there are failures and failures are not accepted
        if not self.accept_failures and failures:
            return None, {}

        # Aggregate loss
        loss_aggregated = weighted_loss_avg(
            [
                (evaluate_res.num_examples, evaluate_res.loss)
                for _, evaluate_res in results
            ]
        )

        # Aggregate custom metrics if aggregation fn was provided

        #print(actv[0].keys())

        metrics_aggregated = {'str':server_round, 
                              'cids' : actv[0]['cids'],
                              'actv_last' : actv[0]['actv_last'] ,
                              'actv_onetolast': actv[0]['actv_onetolast'],
                              'actv_first': actv[0]['actv_first'],
                              'actv_second': actv[0]['actv_second']}


        return loss_aggregated, metrics_aggregated

from keras.layers import Input, Dense, Activation
from keras.models import Model
import numpy as np
import matplotlib.pyplot as plt
import keras.backend as K

def get_layer_outputs(model, layer, input_data, learning_phase=1):
    layer_fn = K.function(model.input, layer.output)
    return layer_fn(input_data)

pd.read_csv('/content/sample_data/mnist_test.csv')

"""## 3. Configurando Simulação"""

def funcao_cliente(cid):
	return ClienteGabriel(int(cid))

history = fl.simulation.start_simulation(client_fn=funcao_cliente, 
								num_clients=n_clients, 
								strategy=AgregacaoCustomizada(fraction_fit=1),
								config=fl.server.ServerConfig(num_rounds=10))


#print(history)

losses = pd.read_csv('acc.csv', names = ['round', 'cid', 'acc', 'loss'])
losses['rodada'] = 1
losses['rodada'] = (losses['rodada'].cumsum() -1)// 7
plt.tight_layout()
plt.figure(figsize = (5,3.67))
plt.grid(True, linestyle=':')
sns.lineplot(data = losses, x = 'rodada', y = 'loss', label = 'Função de perda', color = 'r')
plt.xlabel('Rodada de comunicação')
plt.ylabel('Loss')
plt.savefig('loss_mini.pdf', dpi = 200)

plt.tight_layout()
plt.figure(figsize = (5,3.67))
plt.grid(True, linestyle=':')
sns.lineplot(data = losses, x = 'rodada', y = 'acc', label = 'Acurácia')
plt.xlabel('Rodada de comunicação')
plt.ylabel('Acurácia')
plt.savefig('acc_mini.pdf', dpi = 200)

"""## 4. Visualizando Resultados"""

import matplotlib.pyplot as plt
import numpy as np

#fig, ax = plt.subplots()
plt.figure(figsize = (5,3.67))

results = np.array(history.losses_distributed)
plt.plot(results[::,0] , results[::,1], color='blue')#, label='Loss Treinamento Federado')
plt.grid(True, linestyle=':')
plt.xlabel('Rodada de comunicação')
plt.ylabel('Loss')

plt.savefig('loss_mini.pdf', dpi = 200)

"""## 5.Visualizando os resultados do CKA"""

clientes = history.metrics_distributed['cids'][0][1]

clientes

for i in range(7):
  with open(f'acvt_{i}', "wb") as f:
      pickle.dump(actvs[i], f)

actvs = history.metrics_distributed['actv_last'][0][1] #ativações de todos os clientes na ultima camada no ultimo round

matrix = np.zeros((len(actvs), len(actvs)))

#comparando todos com todos
for i , a in enumerate(actvs):
  for j, b in enumerate(actvs):

    x = int(clientes[i])
    y = int(clientes[j])

    matrix[x][y] = cka(a, b)

plt.figure(figsize = (4.8,3))
plt.tight_layout()
sns.heatmap(matrix, vmin = 0, vmax = 1)

#plt.title('Similaridades por camadas da rede (todas classes no clientes e 1000 amostras).');
plt.savefig('sim_mnist_mini.pdf', dpi = 200)

nome_arquivo = "ckas.pickle"

# Salva a matriz no arquivo pickle
with open(nome_arquivo, "wb") as f:
    pickle.dump(matrix, f)

matrix

sns.heatmap(matrix, vmin = 0, vmax = 1)
#plt.title('Similaridades na ultima camada cliente a cliente')

"""![image.png](data:image/png;base64,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)"""

for i, sim in enumerate(matrix):
  print(i, sim.mean())

actvs = history.metrics_distributed['actv_first'][-1][1] #ativações de todos os clientes na primeira camada no ultimo round

matrix = np.zeros((len(actvs), len(actvs)))

#comparando todos com todos
for i , a in enumerate(actvs):
  for j, b in enumerate(actvs):
    matrix[i][j] = cka(a, b)

sns.heatmap(matrix, vmin = 0, vmax = 1)
plt.title('Similaridades na primeira camada cliente a cliente')

for i, sim in enumerate(matrix):
  print(i, sim.mean())

actvs = history.metrics_distributed['actv_last'][-1][-1] #ativações de todos os clientes na ultima camada no ultimo round

matrix = np.zeros((len(actvs), len(actvs)))

#comparando todos com todos
for i , a in enumerate(actvs):
  for j, b in enumerate(actvs):
    matrix[i][j] = cka(a, b)

sns.heatmap(matrix, vmin = 0, vmax = 1)
plt.title('Similaridades na ultima camada cliente a cliente')

for i, sim in enumerate(matrix):
  print(i, sim.mean())

min = 1
for i in range(len(matrix)):
  for j in range(len(matrix[0])):
    if matrix[i][j] < min:
      min = matrix[i][j]

      x = int(clientes[i])
      y = int(clientes[j])

      cliente = [x, y]

print(f'A similaridade mínima foi de {min}, entre o cliente {cliente[0]} e {cliente[1]}')

max = 0
for i in range(len(matrix)):
  for j in range(len(matrix[0])):
    if (matrix[i][j] > max and i != j):
      max = matrix[i][j]

      x = int(clientes[i])
      y = int(clientes[j])

      cliente = [i, j]

print(f'A similaridade maxima foi de {max}, entre o cliente {cliente[0]} e {cliente[1]}')

camadas = ['actv_first', 'actv_second',  'actv_onetolast','actv_last']

actvs = history.metrics_distributed['actv_first'][-1][-1]
matrixT = np.zeros((len(actvs), len(actvs)))


for c in camadas:

  actvs = history.metrics_distributed[c][-1][-1] #ativações de todos os clientes na ultima camada no ultimo round

  matrix = np.zeros((len(actvs), len(actvs)))

  #comparando todos com todos
  for i , a in enumerate(actvs):
    for j, b in enumerate(actvs):
      matrix[i][j] = cka(a, b)

  matrixT += matrix

matrixT /= 5

min = 1
for i in range(len(matrixT)):
  for j in range(len(matrixT[0])):
    if matrixT[i][j] < min:
      min = matrixT[i][j]

      x = int(clientes[i])
      y = int(clientes[j])

      clientemin = [i, j]

print(f'A similaridade mínima foi de {min}, entre o cliente {clientemin[0]} e {clientemin[1]}')

min = 1
matrixT[clientemin[0]][clientemin[1]] = 1
matrixT[clientemin[1]][clientemin[0]] = 1

for i in range(len(matrixT)):
  for j in range(len(matrixT[0])):
    if matrixT[i][j] < min:
      min = matrixT[i][j]

      x = int(clientes[i])
      y = int(clientes[j])   
         
      clientemin2 = [i, j]

matrixT[clientemin[0]][clientemin[1]] = 0
matrixT[clientemin[1]][clientemin[0]] = 0

print(f'A similaridade mínima (segunda) foi de {min}, entre o cliente {clientemin2[0]} e {clientemin2[1]}')

max = 0
for i in range(len(matrixT)):
  for j in range(len(matrixT[0])):
    if (matrixT[i][j] > max and i != j):
      max = matrixT[i][j]

      x = int(clientes[i])
      y = int(clientes[j])

      clientemax = [i, j]

print(f'A similaridade maxima foi de {max}, entre o cliente {clientemax[0]} e {clientemax[1]}')

max = 0

matrixT[clientemax[0]][clientemax[1]] = 0
matrixT[clientemax[1]][clientemax[0]] = 0

for i in range(len(matrixT)):
  for j in range(len(matrixT[0])):
    if (matrixT[i][j] > max and i != j):
      max = matrixT[i][j]

      x = int(clientes[i])
      y = int(clientes[j])

      clientemax2 = [i, j]

matrixT[clientemax[0]][clientemax[1]] = 1
matrixT[clientemax[1]][clientemax[0]] = 1

print(f'A similaridade maxima (segunda) foi de {max}, entre o cliente {clientemax2[0]} e {clientemax2[1]}')

def sim_camadas(c1, c2):

  l = []

  for c in camadas:

    actvs = history.metrics_distributed[c][-1][-1] #ativações de todos os clientes na ultima camada no ultimo round

    matrix = np.zeros((len(actvs), len(actvs)))

    #comparando todos com todos
    for i , a in enumerate(actvs):
      for j, b in enumerate(actvs):
        matrix[i][j] = cka(a, b)

    l.append(matrix[c1][c2])

  return l

l1 = sim_camadas(clientemin[0], clientemin[1])
l2 = sim_camadas(clientemin2[0], clientemin2[1])
l3 = sim_camadas(clientemax[0], clientemax[1])
l4 = sim_camadas(clientemax2[0], clientemax2[1])

aclientemin =  clientemin

aclientemin2 = clientemin2

aclientemax =  clientemax

aclientemax2 = clientemax2

aclientemin[0] = clientes[clientemin[0]]
aclientemin[1] = clientes[clientemin[1]]

aclientemin2[0] = clientes[clientemin2[0]]
aclientemin2[1] = clientes[clientemin2[1]]

aclientemax[0] = clientes[clientemax[0]]
aclientemax[1] = clientes[clientemax[1]]

aclientemax2[0] = clientes[clientemax2[0]]
aclientemax2[1] = clientes[clientemax2[1]]

import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

sns.set_theme(style='white')

dados = {f'Maior ({aclientemax[0]} e {aclientemax[1]})': l3,
        f'Segundo Maior ({aclientemax2[0]} e {aclientemax2[1]})': l4,
        f'Menor ({aclientemin[0]} e {aclientemin[1]})': l1,
        f'Segundo Menor ({aclientemin2[0]} e {aclientemin2[1]})': l2}
df = pd.DataFrame(dados)

# Definição do estilo do Seaborn
#sns.set_style('darkgrid')

# Criação do gráfico

plt.figure(figsize=(12, 5))
for c in df.columns:
  plt.plot(df[c])
#plt.title('Clientes mais e menos similares')
plt.xlabel('Camada')
plt.ylabel('Similaridade')
plt.legend(title='Clientes', loc='upper left', labels=dados.keys())
plt.show()

df.columns

df = df.reset_index()
df = pd.melt(df, id_vars='index', value_vars= list(df.columns))

df['Camada'] = df['index']+1

df

plt.figure(figsize = (4.5,3))
plt.tight_layout()
sns.barplot(data = df, x = 'Camada', y = 'value', hue = 'variable', edgecolor = 'k', width = 0.5)
#plt.xticks(rotation = 10)
plt.xlabel('Pares')
plt.ylabel('Similaridade')
plt.legend(fontsize = 10, ncols = 2, bbox_to_anchor=(1.12, 1.3))
plt.savefig('sim_barras.pdf', dpi = 200)

data_client_i

dadosMS = pd.DataFrame()


for i in range(n_clients):
  with open(f'{data_path}/client{i+1}.csv', 'rb') as train_file:
    data_client_i = pd.read_csv(train_file).drop('Unnamed: 0', axis = 1) 
    data_client_i['c'] = i+1
  
  dadosMS = dadosMS.append(data_client_i)

cols = list(dadosMS.columns)
cols.remove('label')
cols.remove('c')

def distance(client1, client2):

  distance = 0

  for c in cols:
    distance = distance + wasserstein_distance(client1[c], client2[c])

  return distance

clientemax2[0]

dadosMS[dadosMS['c'] == clientemax2[0]]

d1 = distance(  dadosMS[dadosMS['c'] == int(clientemin[0]) + 1] , dadosMS[dadosMS['c'] == int(clientemin[1])  + 1])
d2 = distance(  dadosMS[dadosMS['c'] == int(clientemin2[0])+ 1] , dadosMS[dadosMS['c'] == int(clientemin2[1]) + 1])
d3 = distance(  dadosMS[dadosMS['c'] == int(clientemax[0] )+ 1] , dadosMS[dadosMS['c'] == int(clientemax[1] ) + 1])
d4 = distance(  dadosMS[dadosMS['c'] == int(clientemax2[0])+ 1] , dadosMS[dadosMS['c'] == int(clientemax2[1]) + 1])

print(d1, d2, d3, d4)

actvs = history.metrics_distributed['actv_first'][-1][-1]
matrixT = np.zeros((len(actvs), len(actvs)))


for c in camadas:

  actvs = history.metrics_distributed[c][-1][-1] #ativações de todos os clientes na ultima camada no ultimo round

  matrix = np.zeros((len(actvs), len(actvs)))

  #comparando todos com todos
  for i , a in enumerate(actvs):
    for j, b in enumerate(actvs):
      matrix[i][j] = cka(a, b)

  matrixT += matrix

matrixT /= 5

matrixD = np.zeros((n_clients, n_clients))
for i in range(n_clients):
  for j in range(n_clients):

    matrixD[i][j] = distance(dadosMS[dadosMS['c'] == i + 1] /255 , dadosMS[dadosMS['c'] == j + 1] / 255)

sns.heatmap(matrixD, cmap = 'rocket_r')#, annot = True)
#plt.title('Distancias (EMD) cliente a cliente');

plt.figure(figsize = (4.8,3))
plt.tight_layout()
sns.heatmap(matrixD, cmap = 'rocket_r')

#plt.title('Similaridades por camadas da rede (todas classes no clientes e 1000 amostras).');
plt.savefig('emd_mnist_mini.pdf', dpi = 200)

corr = []
for i in range(n_clients):
  print(np.corrcoef(matrixT[i], matrixD[i])[0][1])
  corr.append(np.corrcoef(matrixT[i], matrixD[i])[0][1])

plt.figure(figsize = (6,2.5))
sns.boxplot(x = corr)
plt.ylabel('')
plt.xlabel('Coeficiente de Correlação')

actvs = history.metrics_distributed['actv_last'][-1][-1] #ativações de todos os clientes na ultima camada no ultimo round

matrix = np.zeros((len(actvs), len(actvs)))

#comparando todos com todos
for i , a in enumerate(actvs):
  for j, b in enumerate(actvs):
    matrix[i][j] = cka(a, b)

for i in range(n_clients):
  sns.scatterplot(x = matrix[i], y = matrixD[i])
  plt.title(f'Disperção para os dados do cliente {i+1}')

